"""Adaptive DNS tests — only run by AutoML/random strategies."""
import socket


def test_dns_cache_snoop(ip, port):
    """
    DNS cache snooping: query with RD=0 (no recursion) to check
    if cached entries are exposed. Information disclosure vulnerability.
    """
    try:
        # Query for google.com with RD=0 (no recursion desired)
        query = (
            b'\xab\xcf'  # Transaction ID
            b'\x00\x00'  # Flags: RD=0 (no recursion)
            b'\x00\x01'  # Questions: 1
            b'\x00\x00\x00\x00\x00\x00'
            b'\x06google\x03com\x00'
            b'\x00\x01'  # Type A
            b'\x00\x01'  # Class IN
        )

        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        sock.sendto(query, (ip, port))
        data, _ = sock.recvfrom(512)
        sock.close()

        # Server responded to non-recursive query = cache snooping possible
        if len(data) >= 12:
            rcode = data[3] & 0x0F
            return rcode == 0  # NOERROR means it tried to answer
        return False
    except Exception:
        return False


def test_dns_any_query(ip, port):
    """
    Send a DNS ANY query. Servers that respond to ANY queries
    can be used for DNS amplification attacks.
    """
    try:
        query = (
            b'\xab\xd0'  # Transaction ID
            b'\x01\x00'  # Flags: standard query
            b'\x00\x01'  # Questions: 1
            b'\x00\x00\x00\x00\x00\x00'
            b'\x03iot\x05local\x00'
            b'\x00\xff'  # Type ANY
            b'\x00\x01'  # Class IN
        )

        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        sock.sendto(query, (ip, port))
        data, _ = sock.recvfrom(4096)
        sock.close()

        # Large response to ANY = amplification risk
        return len(data) > 50
    except Exception:
        return False


def test_dns_version_disclosure(ip, port):
    """
    Query version.bind CHAOS TXT to check if the DNS server
    reveals its version — a fingerprinting vulnerability.
    """
    try:
        query = (
            b'\xab\xd1'  # Transaction ID
            b'\x01\x00'  # Flags
            b'\x00\x01'  # Questions: 1
            b'\x00\x00\x00\x00\x00\x00'
            # version.bind
            b'\x07version\x04bind\x00'
            b'\x00\x10'  # Type TXT
            b'\x00\x03'  # Class CHAOS
        )

        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        sock.sendto(query, (ip, port))
        data, _ = sock.recvfrom(512)
        sock.close()

        if len(data) >= 12:
            ancount = int.from_bytes(data[6:8], 'big')
            return ancount > 0
        return False
    except Exception:
        return False
