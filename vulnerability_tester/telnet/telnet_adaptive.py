"""
Adaptive Telnet test variants -- ONLY executed by the AutoML/adaptive strategy.
These tests go beyond the static telnet_open check to probe for default
credentials, banner information leakage, and plaintext transmission risks.
"""
import socket
import logging


def test_telnet_default_credentials(ip, port, timeout=5):
    """
    Try common default credential pairs via telnet login prompt.
    Returns True if any credential pair results in a successful login
    (indicated by a shell prompt or welcome message after credential submission).
    """
    credentials = [
        ("root", "root"),
        ("admin", "admin"),
        ("admin", "password"),
        ("root", ""),
        ("admin", ""),
        ("user", "user"),
        ("root", "toor"),
        ("default", "default"),
    ]

    for username, password in credentials:
        try:
            sock = socket.create_connection((ip, port), timeout=timeout)
            # Read initial banner/login prompt
            banner = b""
            try:
                sock.settimeout(2)
                banner = sock.recv(4096)
            except socket.timeout:
                pass

            # Send username
            sock.send((username + "\n").encode())
            try:
                sock.settimeout(2)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""

            # Send password
            sock.send((password + "\n").encode())
            try:
                sock.settimeout(3)
                result = sock.recv(4096)
            except socket.timeout:
                result = b""

            sock.close()

            result_lower = result.decode(errors="ignore").lower()
            # Check for indicators of successful login
            success_indicators = ["$", "#", ">", "welcome", "last login",
                                  "busybox", "shell", "root@", "admin@"]
            fail_indicators = ["incorrect", "denied", "failed", "invalid",
                              "authentication failure", "login incorrect"]

            if any(ind in result_lower for ind in fail_indicators):
                continue

            if any(ind in result_lower for ind in success_indicators):
                logging.debug(
                    f"[telnet_default_creds] Login succeeded with {username}:{password} on {ip}:{port}"
                )
                return True

        except Exception:
            pass

    return False


def test_telnet_banner_info_leak(ip, port, timeout=5):
    """
    Check if the telnet banner reveals sensitive information such as
    OS version, kernel version, device model, or software versions.
    Information leakage in banners aids attacker reconnaissance.
    """
    try:
        sock = socket.create_connection((ip, port), timeout=timeout)
        sock.settimeout(3)
        banner = sock.recv(4096).decode(errors="ignore")
        sock.close()

        if not banner:
            return False

        banner_lower = banner.lower()
        # Indicators of information leakage in banners
        info_patterns = [
            "linux", "ubuntu", "debian", "centos", "busybox",
            "kernel", "version", "release", "firmware",
            "openwrt", "dd-wrt", "mikrotik", "cisco",
            "welcome to", "model", "build",
        ]

        for pattern in info_patterns:
            if pattern in banner_lower:
                logging.debug(
                    f"[telnet_banner_leak] Banner info leak on {ip}:{port}: "
                    f"contains '{pattern}'"
                )
                return True

        return False

    except Exception:
        return False


def test_telnet_no_encryption(ip, port, timeout=5):
    """
    Verify that telnet transmits data in plaintext without TLS/SSL.
    This is always a vulnerability when telnet is accessible, as all
    credentials and commands are transmitted unencrypted.
    The test confirms the connection is raw TCP (no TLS negotiation).
    """
    try:
        sock = socket.create_connection((ip, port), timeout=timeout)
        sock.settimeout(2)

        # Read initial data â€” if we get readable text, it's plaintext
        try:
            data = sock.recv(1024)
        except socket.timeout:
            data = b""

        sock.close()

        # TLS connections would start with a TLS handshake (byte 0x16)
        # or would fail to produce readable ASCII text
        if data and len(data) > 0:
            # Check it's NOT a TLS handshake
            if data[0] != 0x16:
                logging.debug(
                    f"[telnet_no_encryption] Plaintext telnet on {ip}:{port}"
                )
                return True

        # If we connected successfully, it's telnet (plaintext by design)
        return True

    except Exception:
        return False
